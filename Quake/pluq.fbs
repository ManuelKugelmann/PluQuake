// pluq.fbs - PluQ FlatBuffers Schema
// Three-channel IPC protocol for Quake game state streaming

namespace PluQ;

// ============================================================================
// COMMON TYPES
// ============================================================================

// High-precision Vec3 for resources/models
struct Vec3 {
  x: float;
  y: float;
  z: float;
}

// Coordinate type matching Quake's MSG_WriteCoord
// 16-bit integers with 3 fractional bits (divide by 8.0 to get float)
// Range: -4096 to +4096 units with 0.125 precision
struct Vec3Coord {
  x: int16;
  y: int16;
  z: int16;
}

// Angle type matching Quake's MSG_WriteAngle
// 8-bit unsigned (multiply by 360.0/256.0 to get degrees)
// Precision: 1.40625 degrees
struct Vec3Angle {
  pitch: uint8;
  yaw: uint8;
  roll: uint8;
}

// ============================================================================
// RESOURCES CHANNEL - On-demand resource data only (REQ/REP)
// Frontend requests specific resources by ID
// Backend replies with resource data
// ============================================================================

enum ResourceType : byte {
  None = 0,
  Texture = 1,
  Model = 2,
  BSPVertices = 3,
  BSPFaces = 4,
  Lightmap = 5
}

// Frontend  to  Backend: Request a specific resource
table ResourceRequest {
  resource_type: ResourceType;
  resource_id: uint32;
  resource_name: string;  // Optional: request by name instead of ID
}

table Texture {
  id: uint32;
  name: string;
  width: uint16;
  height: uint16;
  format: byte;  // 0=RGBA, 1=RGB, 2=Indexed
  pixels: [ubyte];
}

table Model {
  id: uint32;
  name: string;
  num_vertices: uint32;
  num_triangles: uint32;
  num_frames: uint32;
  vertices: [float];      // Packed: x,y,z for each vertex
  triangles: [uint16];    // Triangle indices
  texcoords: [float];     // UV coordinates
  normals: [float];       // Normals
}

table BSPVertices {
  vertices: [Vec3];
}

table BSPFace {
  plane_id: uint32;
  side: byte;
  first_edge: uint32;
  num_edges: uint16;
  texture_id: uint16;
  lightmap_offset: uint32;
  styles: [byte];
}

table BSPFaces {
  faces: [BSPFace];
}

table Lightmap {
  id: uint32;
  width: uint16;
  height: uint16;
  data: [ubyte];  // RGB lightmap data
}

// Resource lookup table entry
table ResourceInfo {
  id: uint32;
  type: ResourceType;
  name: string;
  size: uint32;  // Size in bytes (for progress bars)
}

union ResourceData {
  Texture,
  Model,
  BSPVertices,
  BSPFaces,
  Lightmap
}

// Backend  to  Frontend: Resource response (REP)
table ResourceResponse {
  resource_id: uint32;
  data: ResourceData;
}

// ============================================================================
// GAMEPLAY CHANNEL - All game state events (PUB/SUB)
// Includes: map changes, frame updates, disconnects, etc.
// ============================================================================

// Map changed event (sent when map loads)
table MapChanged {
  mapname: string;

  // Resource lookup table - frontend can use this to decide:
  // 1. Load locally (if it has pak files)
  // 2. Request from backend (if it doesn't)
  resources: [ResourceInfo];
}

// Disconnect event
table Disconnected {
  reason: string;
}

// Entity in the game world
table Entity {
  origin: Vec3Coord;
  angles: Vec3Angle;
  model_id: uint16;
  frame: byte;
  colormap: byte;
  skin: byte;
  effects: uint32;
  alpha: ubyte;           // 0-255
}

// Frame update (sent every tick)
table FrameUpdate {
  frame_number: uint32;
  timestamp: float;

  // View state
  view_origin: Vec3Coord;
  view_angles: Vec3Angle;

  // Player stats
  health: int16;
  armor: int16;
  weapon: byte;
  ammo: uint16;

  // Game state
  paused: bool;
  in_game: bool;

  // Entities
  entities: [Entity];
}

// Union of all gameplay events
union GameplayEvent {
  MapChanged,
  FrameUpdate,
  Disconnected
}

// Gameplay message (sent on gameplay channel)
table GameplayMessage {
  event: GameplayEvent;
}

// ============================================================================
// INPUT CHANNEL - User input (from frontend to backend)
// ============================================================================

table InputCommand {
  sequence: uint32;
  timestamp: float;

  // Movement
  forward_move: int16;
  side_move: int16;
  up_move: int16;

  // View
  view_angles: Vec3Angle;

  // Buttons (bitfield)
  buttons: uint32;

  // Impulse
  impulse: byte;

  // Console command (optional)
  cmd_text: string;
}

// ============================================================================
// ROOT TYPES
// ============================================================================
// Note: FlatBuffers only allows one root_type per schema.
// For multi-channel IPC, we don't use root_type - just access tables directly.
// Each channel uses specific message types:
// - Resources channel: ResourceRequest (frontend->backend), ResourceResponse (backend->frontend)
// - Gameplay channel: GameplayMessage (backend->frontend)
// - Input channel: InputCommand (frontend->backend)
